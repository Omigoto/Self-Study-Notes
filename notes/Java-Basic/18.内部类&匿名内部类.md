#### 内部类

如果一个事物的内部包含另一事物，那么这就是一个类内部包含另一个类

例如：身体和心脏的关系，又例如汽车和发动机的关系



分类：

1. 成员内部类
2. 局部内部类

**成员内部类**的定义格式：

修饰符 class 类名称 {

​		修饰符 class 类名称 {

​				//...

​		}

​		//...

}

注意：内用外，随意访问；需要内部类对象



使用成员内部类有两种方式：

1. 间接方式：在外部类的方法当中，使用内部类；然后main只是调用外部类的方法

2. 直接方式： 公式：

   外部类名称.内部类名称  对象名  =  new 外部类名称().new  内部类名称();



如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量名



**局部内部类:**

如果一个类是定义在一个方法内部的，那么这就是一个局部内部类

”局部“：只有当前所属的方法才能使用它，除了这个方法外面就不能用了



定义格式：

修饰符  class  外部类名称  {

​	修饰符  返回值类型  外部类方法名称（参数列表） {

​			class  局部内部类名称  {

​					//...

​			}

​	}

}



小节以下类的权限修饰符：

public > protected  > (default)  > private

定义一个类的时候，权限修饰符规则：

1. 外部类 ： public  /  (default)
2. 成员内部类 ：public / protected / (default) / private
3. 局部内部类 ：什么都不能写,只能在方法内部访问

局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】

**备注：**从Java8+开始，只要局部变量事实不变，那么final关键字可以省略

**原因：**

1. new出来的对象在堆内存当中
2. 局部变量是跟着方法走的，在栈内存当中
3. 方法运行结束后，立刻出栈，局部变量就会立刻消失
4. 但是new出来的对象会立在堆当中持续存在，直到垃圾回收消失



局部内部类当中的**匿名内部类**

如果接口的实现类（或者是父类的子类）只需要使用唯一的一次

那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】

**匿名内部类的定义格式：**

接口名称  对象名  =  new  接口名称（） {

​		//覆盖重写所有抽象类方法

}；



对格式进行解析”new  接口名称（）{...}“：

1. new代表创建对象的动作

2. 接口名称就是匿名内部类需要实现哪个接口

3. {...}这才是匿名内部类的内容

   另外还要注意几点问题

   - 匿名内部类，在【创建对象】的时候，只能使用唯一一次

   如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了

   - 匿名对象，在【调用方法】的时候，只能调用唯一一次

     如果希望同一个对象，调用多次方法，那么必须给对象起个名字

   - 匿名内部类是省略了【实现类/子类】，但是匿名对象是省略了【对象名称】

**强调：**匿名内部类和匿名对象不是一回事